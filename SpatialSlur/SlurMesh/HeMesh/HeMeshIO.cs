using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.IO;

using SpatialSlur.SlurCore;

/*
 * Notes
 */ 

namespace SpatialSlur.SlurMesh
{
    /// <summary>
    /// Various static methods for importing and exporting mesh data.
    /// </summary>
    public static class HeMeshIO
    {
        private const string _headerOBJ = "# Generated by SpatialSlur https://github.com/daveReeves/SpatialSlur";
        private static readonly string[] _faceFormatsOBJ = new string[] { " {0}", " {0}/{0}", " {0}//{0}", " {0}/{0}/{0}" };
        private static readonly char[] _separatorsOBJ = new char[]{ ' ', '\t', '\0' };
        private static readonly char[] _faceSeparatorsOBJ = new char[] { '/' };


        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="TV"></typeparam>
        /// <typeparam name="TE"></typeparam>
        /// <typeparam name="TF"></typeparam>
        /// <param name="mesh"></param>
        /// <param name="path"></param>
        /// <param name="getPosition"></param>
        public static void WriteToOBJ<TV,TE,TF>(HeMeshBase<TV, TE, TF> mesh, string path, Func<TV, Vec3d> getPosition)
            where TV : HeVertex<TV, TE, TF>
            where TE : Halfedge<TV, TE, TF>
            where TF : HeFace<TV, TE, TF>
        {
            WriteToOBJ(mesh, path, getPosition, null, null);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="TV"></typeparam>
        /// <typeparam name="TE"></typeparam>
        /// <typeparam name="TF"></typeparam>
        /// <param name="mesh"></param>
        /// <param name="path"></param>
        /// <param name="getPosition"></param>
        /// <param name="getNormal"></param>
        /// <param name="getTexture"></param>
        public static void WriteToOBJ<TV, TE, TF>(HeMeshBase<TV, TE, TF> mesh, string path, Func<TV, Vec3d> getPosition, Func<TV, Vec3d> getNormal, Func<TV, Vec2d> getTexture)
            where TV : HeVertex<TV, TE, TF>
            where TE : Halfedge<TV, TE, TF>
            where TF : HeFace<TV, TE, TF>
        {
            var verts = mesh.Vertices;
            var faces = mesh.Faces;
            int formatIndex = 0;

            using (var writer = new StreamWriter(path, false, Encoding.ASCII))
            {
                writer.WriteLine(_headerOBJ);
                writer.WriteLine();

                // write vertex positions
                for (int i = 0; i < verts.Count; i++)
                {
                    var v = getPosition(verts[i]);
                    writer.WriteLine("v {0} {1} {2}", v.X, v.Y, v.Z);
                }

                // write vertex normals
                if (getNormal != null)
                {
                    for (int i = 0; i < verts.Count; i++)
                    {
                        var vn = getNormal(verts[i]);
                        writer.WriteLine("vn {0} {1} {2}", vn.X, vn.Y, vn.Z);
                    }

                    formatIndex |= 2;
                }

                // write vertex texCoords
                if (getTexture != null)
                {
                    for (int i = 0; i < verts.Count; i++)
                    {
                        var vt = getTexture(verts[i]);
                        writer.WriteLine("vt {0} {1}", vt.X, vt.Y);
                    }

                    formatIndex |= 1;
                }
                
                // write faces
                string format = _faceFormatsOBJ[formatIndex];
               
                for (int i = 0; i < faces.Count; i++)
                {
                    var f = faces[i];
                    if (f.IsRemoved) continue;

                    writer.Write("f");
                    foreach (var v in f.Vertices)
                        writer.Write(format, v.Index + 1);

                    writer.WriteLine();
                }
            }
        }


        /// <summary>
        /// Implementation currently ignores texture coordinates and normals.
        /// </summary>
        /// <typeparam name="TV"></typeparam>
        /// <typeparam name="TE"></typeparam>
        /// <typeparam name="TF"></typeparam>
        /// <param name="path"></param>
        /// <param name="mesh"></param>
        /// <param name="setPosition"></param>
        public static void ReadFromOBJ<TV,TE,TF>(string path, HeMeshBase<TV, TE, TF> mesh, Action<TV, Vec3d> setPosition)
            where TV : HeVertex<TV, TE, TF>
            where TE : Halfedge<TV, TE, TF>
            where TF : HeFace<TV, TE, TF>
        {
            var verts = mesh.Vertices;
            var faces = mesh.Faces;
            var face = new List<int>();

            using (var reader = new StreamReader(path, Encoding.ASCII))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    // skip empty lines and comments
                    if (line.Length == 0 || line[0] == '#') continue;

                    // check the first character
                    var segments = line.Split(_separatorsOBJ, StringSplitOptions.RemoveEmptyEntries);
                    switch (segments[0])
                    {
                        case "v":
                            {
                                // parse vertex
                                double x = double.Parse(segments[1]);
                                double y = double.Parse(segments[2]);
                                double z = double.Parse(segments[3]);

                                var v = mesh.AddVertex();
                                setPosition(v, new Vec3d(x, y, z));
                                break;
                            }
                        case "f":
                            {
                                // parse face
                                for (int i = 1; i < segments.Length; i++)
                                {
                                    var ids = segments[i].Split(_faceSeparatorsOBJ);
                                    face.Add(int.Parse(ids[0]) - 1);
                                }

                                mesh.AddFace(face);
                                face.Clear();
                                break;
                            }
                    }
                }
            }
        }
    }
}
