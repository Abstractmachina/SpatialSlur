using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.IO;

using SpatialSlur.SlurCore;

/*
 * Notes
 */ 

namespace SpatialSlur.SlurMesh
{
    /// <summary>
    /// Various static methods for importing and exporting mesh data.
    /// </summary>
    public static class HeMeshIO
    {
        private const string ObjHeader = "# Generated by SpatialSlur https://github.com/daveReeves/SpatialSlur";

        private static readonly string[] _objFaceFormats = new string[] { " {0}", " {0}/{0}", " {0}//{0}", " {0}/{0}/{0}" };
        private static readonly char[] _objSeparators = new char[]{ ' ', '\t', '\0' };
        private static readonly char[] _objFaceSeparator = new char[] { '/' };


        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="TV"></typeparam>
        /// <typeparam name="TE"></typeparam>
        /// <typeparam name="TF"></typeparam>
        /// <param name="source"></param>
        /// <param name="path"></param>
        /// <param name="getPosition"></param>
        public static void WriteOBJ<TV,TE,TF>(HeMesh<TV, TE, TF> source, string path, Func<TV, Vec3d> getPosition)
            where TV : HeVertex<TV, TE, TF>
            where TE : Halfedge<TV, TE, TF>
            where TF : HeFace<TV, TE, TF>
        {
            WriteOBJ(source, path, getPosition, null, null);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="TV"></typeparam>
        /// <typeparam name="TE"></typeparam>
        /// <typeparam name="TF"></typeparam>
        /// <param name="source"></param>
        /// <param name="path"></param>
        /// <param name="getPosition"></param>
        /// <param name="getNormal"></param>
        /// <param name="getTexCoord"></param>
        public static void WriteOBJ<TV, TE, TF>(HeMesh<TV, TE, TF> source, string path, Func<TV, Vec3d> getPosition, Func<TV, Vec3d> getNormal, Func<TV, Vec3d> getTexCoord)
            where TV : HeVertex<TV, TE, TF>
            where TE : Halfedge<TV, TE, TF>
            where TF : HeFace<TV, TE, TF>
        {
            var verts = source.Vertices;
            var faces = source.Faces;
            int formatIndex = 0;

            using (var writer = new StreamWriter(path, false, Encoding.ASCII))
            {
                writer.WriteLine(ObjHeader);
                writer.WriteLine();

                // write vertex positions
                for (int i = 0; i < verts.Count; i++)
                {
                    var v = getPosition(verts[i]);
                    writer.WriteLine("v {0} {1} {2}", v.X, v.Y, v.Z);
                }

                // write vertex normals
                if (getNormal != null)
                {
                    for (int i = 0; i < verts.Count; i++)
                    {
                        var vn = getNormal(verts[i]);
                        writer.WriteLine("vn {0} {1} {2}", vn.X, vn.Y, vn.Z);
                    }

                    formatIndex |= 2;
                }

                // write vertex texCoords
                if (getTexCoord != null)
                {
                    for (int i = 0; i < verts.Count; i++)
                    {
                        var vt = getTexCoord(verts[i]);
                        writer.WriteLine("vt {0} {1}", vt.X, vt.Y);
                    }

                    formatIndex |= 1;
                }
                
                // write faces
                string format = _objFaceFormats[formatIndex];
               
                for (int i = 0; i < faces.Count; i++)
                {
                    var f = faces[i];
                    if (f.IsRemoved) continue;

                    writer.Write("f");
                    foreach (var v in f.Vertices)
                        writer.Write(format, v.Index + 1);

                    writer.WriteLine();
                }
            }
        }


        /// <summary>
        /// Implementation currently ignores texture coordinates and normals.
        /// </summary>
        /// <typeparam name="TV"></typeparam>
        /// <typeparam name="TE"></typeparam>
        /// <typeparam name="TF"></typeparam>
        /// <param name="path"></param>
        /// <param name="destination"></param>
        /// <param name="setPosition"></param>
        public static void ReadOBJ<TV,TE,TF>(string path, HeMesh<TV,TE,TF> destination, Action<TV, Vec3d> setPosition)
            where TV : HeVertex<TV, TE, TF>
            where TE : Halfedge<TV, TE, TF>
            where TF : HeFace<TV, TE, TF>
        {
            var verts = destination.Vertices;
            var faces = destination.Faces;
            var face = new List<int>();

            using (var reader = new StreamReader(path, Encoding.ASCII))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    // skip empty lines and comments
                    if (line.Length == 0 || line[0] == '#') continue;

                    // check the first character
                    var segments = line.Split(_objSeparators, StringSplitOptions.RemoveEmptyEntries);
                    switch (segments[0])
                    {
                        case "v":
                            {
                                // parse vertex
                                double x = double.Parse(segments[1]);
                                double y = double.Parse(segments[2]);
                                double z = double.Parse(segments[3]);

                                var v = destination.AddVertex();
                                setPosition(v, new Vec3d(x, y, z));
                                break;
                            }
                        case "f":
                            {
                                // parse face
                                for (int i = 1; i < segments.Length; i++)
                                {
                                    var ids = segments[i].Split(_objFaceSeparator);
                                    face.Add(int.Parse(ids[0]) - 1);
                                }

                                destination.AddFace(face);
                                face.Clear();
                                break;
                            }
                    }
                }
            }
        }
    }
}
