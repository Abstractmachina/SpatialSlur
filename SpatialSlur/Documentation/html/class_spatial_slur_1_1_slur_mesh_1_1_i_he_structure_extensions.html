<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SpatialSlur: SpatialSlur.SlurMesh.IHeStructureExtensions Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SpatialSlur
   &#160;<span id="projectnumber">0.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_spatial_slur.html">SpatialSlur</a></li><li class="navelem"><a class="el" href="namespace_spatial_slur_1_1_slur_mesh.html">SlurMesh</a></li><li class="navelem"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html">IHeStructureExtensions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SpatialSlur.SlurMesh.IHeStructureExtensions Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p> 
 <a href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0c25e5c4452802ad9de205c03547e618"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a0c25e5c4452802ad9de205c03547e618">CountConnectedComponents&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph)</td></tr>
<tr class="memdesc:a0c25e5c4452802ad9de205c03547e618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected components in the graph.  <a href="#a0c25e5c4452802ad9de205c03547e618">More...</a><br /></td></tr>
<tr class="separator:a0c25e5c4452802ad9de205c03547e618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d8d9b054a218122a14323bb6ab6f06"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ac3d8d9b054a218122a14323bb6ab6f06">GetConnectedComponents&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph)</td></tr>
<tr class="memdesc:ac3d8d9b054a218122a14323bb6ab6f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first halfedge from each connected component in the graph.  <a href="#ac3d8d9b054a218122a14323bb6ab6f06">More...</a><br /></td></tr>
<tr class="separator:ac3d8d9b054a218122a14323bb6ab6f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ecfb70d9b98547787fd0cb1a11a8aa"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ac6ecfb70d9b98547787fd0cb1a11a8aa">GetEdgesBreadthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; E &gt; sources)</td></tr>
<tr class="memdesc:ac6ecfb70d9b98547787fd0cb1a11a8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns edges in breadth first order.  <a href="#ac6ecfb70d9b98547787fd0cb1a11a8aa">More...</a><br /></td></tr>
<tr class="separator:ac6ecfb70d9b98547787fd0cb1a11a8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927a399748e1bbeb57a5bcf4bba300ec"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a927a399748e1bbeb57a5bcf4bba300ec">GetEdgesBreadthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; E &gt; sources, IEnumerable&lt; E &gt; exclude)</td></tr>
<tr class="memdesc:a927a399748e1bbeb57a5bcf4bba300ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns edges in breadth first order.  <a href="#a927a399748e1bbeb57a5bcf4bba300ec">More...</a><br /></td></tr>
<tr class="separator:a927a399748e1bbeb57a5bcf4bba300ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a8810107dc9c8f193f99310aa769e"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a9a8a8810107dc9c8f193f99310aa769e">GetEdgesDepthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; E &gt; sources)</td></tr>
<tr class="memdesc:a9a8a8810107dc9c8f193f99310aa769e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns edges in depth first order.  <a href="#a9a8a8810107dc9c8f193f99310aa769e">More...</a><br /></td></tr>
<tr class="separator:a9a8a8810107dc9c8f193f99310aa769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22697df40e9068792d6e0f0575b35f1"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aa22697df40e9068792d6e0f0575b35f1">GetEdgesDepthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; E &gt; sources, IEnumerable&lt; E &gt; exclude)</td></tr>
<tr class="memdesc:aa22697df40e9068792d6e0f0575b35f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns edges in depth first order.  <a href="#aa22697df40e9068792d6e0f0575b35f1">More...</a><br /></td></tr>
<tr class="separator:aa22697df40e9068792d6e0f0575b35f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8830116787d213e17451a9790e7ab1d3"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a8830116787d213e17451a9790e7ab1d3">GetEdgesPriorityFirst&lt; V, E, T &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; E &gt; sources, Func&lt; E, T &gt; getPriority)</td></tr>
<tr class="memdesc:a8830116787d213e17451a9790e7ab1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns edges in order of increasing priority.  <a href="#a8830116787d213e17451a9790e7ab1d3">More...</a><br /></td></tr>
<tr class="separator:a8830116787d213e17451a9790e7ab1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe91bbbf3dd6561305282efcf7fa635c"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#afe91bbbf3dd6561305282efcf7fa635c">GetEdgesPriorityFirst&lt; V, E, T &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; E &gt; sources, Func&lt; E, T &gt; getPriority, IEnumerable&lt; E &gt; exclude)</td></tr>
<tr class="memdesc:afe91bbbf3dd6561305282efcf7fa635c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns edges in order of increasing priority.  <a href="#afe91bbbf3dd6561305282efcf7fa635c">More...</a><br /></td></tr>
<tr class="separator:afe91bbbf3dd6561305282efcf7fa635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08e2f1e6653508428ea2590bcd2a143"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aa08e2f1e6653508428ea2590bcd2a143">GetVerticesBreadthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources)</td></tr>
<tr class="memdesc:aa08e2f1e6653508428ea2590bcd2a143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vertices in breadth first order via the traversed halfedge.  <a href="#aa08e2f1e6653508428ea2590bcd2a143">More...</a><br /></td></tr>
<tr class="separator:aa08e2f1e6653508428ea2590bcd2a143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2692310d9f476d0c8ad3701fddbc2f"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a5b2692310d9f476d0c8ad3701fddbc2f">GetVerticesBreadthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources, IEnumerable&lt; V &gt; exclude)</td></tr>
<tr class="memdesc:a5b2692310d9f476d0c8ad3701fddbc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vertices in breadth first order via the traversed halfedge.  <a href="#a5b2692310d9f476d0c8ad3701fddbc2f">More...</a><br /></td></tr>
<tr class="separator:a5b2692310d9f476d0c8ad3701fddbc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9767b01aec019fb9df5efadd2e983ab0"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a9767b01aec019fb9df5efadd2e983ab0">GetVerticesDepthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources)</td></tr>
<tr class="memdesc:a9767b01aec019fb9df5efadd2e983ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vertices in depth first order via the traversed halfedge.  <a href="#a9767b01aec019fb9df5efadd2e983ab0">More...</a><br /></td></tr>
<tr class="separator:a9767b01aec019fb9df5efadd2e983ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c9c4b62fc592840d45e0e16ca51662"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#af2c9c4b62fc592840d45e0e16ca51662">GetVerticesDepthFirst&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources, IEnumerable&lt; V &gt; exclude)</td></tr>
<tr class="memdesc:af2c9c4b62fc592840d45e0e16ca51662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vertices in depth first order via the traversed halfedge.  <a href="#af2c9c4b62fc592840d45e0e16ca51662">More...</a><br /></td></tr>
<tr class="separator:af2c9c4b62fc592840d45e0e16ca51662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab095a0437b7977ffe1e571264ee9350e"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ab095a0437b7977ffe1e571264ee9350e">GetVerticesPriorityFirst&lt; V, E, T &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources, Func&lt; V, T &gt; getPriority)</td></tr>
<tr class="memdesc:ab095a0437b7977ffe1e571264ee9350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vertices in order of increasing priority via the traversed halfedge.  <a href="#ab095a0437b7977ffe1e571264ee9350e">More...</a><br /></td></tr>
<tr class="separator:ab095a0437b7977ffe1e571264ee9350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ac13c72844bfc1de0df775f8e92760"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a19ac13c72844bfc1de0df775f8e92760">GetVerticesPriorityFirst&lt; V, E, T &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources, Func&lt; V, T &gt; getPriority, IEnumerable&lt; V &gt; exclude)</td></tr>
<tr class="memdesc:a19ac13c72844bfc1de0df775f8e92760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vertices in order of increasing priority via the traversed halfedge.  <a href="#a19ac13c72844bfc1de0df775f8e92760">More...</a><br /></td></tr>
<tr class="separator:a19ac13c72844bfc1de0df775f8e92760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d328dfdf8f0d012cddb1d74e8c05a00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a1d328dfdf8f0d012cddb1d74e8c05a00">GetHalfedgeAngles&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; E, double &gt; setAngle, bool parallel=false)</td></tr>
<tr class="separator:a1d328dfdf8f0d012cddb1d74e8c05a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fc50cc7c07a6321ce6edf57d714b15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a09fc50cc7c07a6321ce6edf57d714b15">GetHalfedgeAngles&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; E, double &gt; getLength, Action&lt; E, double &gt; setAngle, bool parallel=false)</td></tr>
<tr class="separator:a09fc50cc7c07a6321ce6edf57d714b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a47415effa524c9f7bbaca65b043081"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a2a47415effa524c9f7bbaca65b043081">GetEdgeDeltas&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, double &gt; getValue, Action&lt; E, double &gt; setDelta, bool parallel=false)</td></tr>
<tr class="separator:a2a47415effa524c9f7bbaca65b043081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49445752442bbfee5681c698585e845a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a49445752442bbfee5681c698585e845a">GetEdgeDeltas&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt; getValue, Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt; setDelta, bool parallel=false)</td></tr>
<tr class="separator:a49445752442bbfee5681c698585e845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fd0b0658f93d579c52094808c42050"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ab3fd0b0658f93d579c52094808c42050">GetEdgeDeltas&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getValue, Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setDelta, bool parallel=false)</td></tr>
<tr class="separator:ab3fd0b0658f93d579c52094808c42050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c64678eb7fc396772bbd6a8e47e86b7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a3c64678eb7fc396772bbd6a8e47e86b7">GetEdgeLengthSum&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition)</td></tr>
<tr class="separator:a3c64678eb7fc396772bbd6a8e47e86b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0006bc10f877c8e6d40749a140040774"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a0006bc10f877c8e6d40749a140040774">GetEdgeLengths&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; E, double &gt; setLength, bool parallel=false)</td></tr>
<tr class="separator:a0006bc10f877c8e6d40749a140040774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6130ffd2dcff67449b8a03d323bdb42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ac6130ffd2dcff67449b8a03d323bdb42">GetEdgeTangents&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setTangent, bool parallel=false)</td></tr>
<tr class="separator:ac6130ffd2dcff67449b8a03d323bdb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135c02a70215035b83572ba53d6a4595"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a135c02a70215035b83572ba53d6a4595">GetEdgeComponentIndices&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Action&lt; E, int &gt; setIndex)</td></tr>
<tr class="memdesc:a135c02a70215035b83572ba53d6a4595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected component index of each edge in the mesh. Also returns the number of connected components.  <a href="#a135c02a70215035b83572ba53d6a4595">More...</a><br /></td></tr>
<tr class="separator:a135c02a70215035b83572ba53d6a4595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e691f5dec2349b6bfae6f8e25dabfc8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a4e691f5dec2349b6bfae6f8e25dabfc8">GetEdgeDepths&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; E &gt; sources, Func&lt; E, int &gt; getDepth, Action&lt; E, int &gt; setDepth)</td></tr>
<tr class="memdesc:a4e691f5dec2349b6bfae6f8e25dabfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum topological depth of each edge from a collection of sources. Note that corresponding get/set delegates must read/write to the same location.  <a href="#a4e691f5dec2349b6bfae6f8e25dabfc8">More...</a><br /></td></tr>
<tr class="separator:a4e691f5dec2349b6bfae6f8e25dabfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4cdc2e32bc894bfa0d3c9f0106705d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a6b4cdc2e32bc894bfa0d3c9f0106705d">GetVertexDegrees&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Action&lt; V, int &gt; setDegree, bool parallel=false)</td></tr>
<tr class="separator:a6b4cdc2e32bc894bfa0d3c9f0106705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18e5e6ff85b84279d134c9942c4199"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a8a18e5e6ff85b84279d134c9942c4199">GetVertexLaplacian&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, double &gt; getValue, Action&lt; V, double &gt; setLaplace, bool parallel=false)</td></tr>
<tr class="memdesc:a8a18e5e6ff85b84279d134c9942c4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian of the given vertex attributes using a normalized umbrella weighting scheme. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a>  <a href="#a8a18e5e6ff85b84279d134c9942c4199">More...</a><br /></td></tr>
<tr class="separator:a8a18e5e6ff85b84279d134c9942c4199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f4244f1f995281265dc8394b2c3d63"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a01f4244f1f995281265dc8394b2c3d63">GetVertexLaplacian&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt; getValue, Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt; setLaplace, bool parallel=false)</td></tr>
<tr class="memdesc:a01f4244f1f995281265dc8394b2c3d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian of the given vertex attributes using a normalized umbrella weighting scheme. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a>  <a href="#a01f4244f1f995281265dc8394b2c3d63">More...</a><br /></td></tr>
<tr class="separator:a01f4244f1f995281265dc8394b2c3d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063abbaf126bdabb5604b91e9e6b9675"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a063abbaf126bdabb5604b91e9e6b9675">GetVertexLaplacian&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getValue, Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setLaplace, bool parallel=false)</td></tr>
<tr class="memdesc:a063abbaf126bdabb5604b91e9e6b9675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian of the given vertex attributes using a normalized umbrella weighting scheme. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a>  <a href="#a063abbaf126bdabb5604b91e9e6b9675">More...</a><br /></td></tr>
<tr class="separator:a063abbaf126bdabb5604b91e9e6b9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2527d242ff10ff0841c22574ce98cac5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a2527d242ff10ff0841c22574ce98cac5">GetVertexLaplacian&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, double &gt; getValue, Func&lt; E, double &gt; getWeight, Action&lt; V, double &gt; setLaplace, bool parallel=false)</td></tr>
<tr class="memdesc:a2527d242ff10ff0841c22574ce98cac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian of the given vertex attributes using given halfedge weights. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a>  <a href="#a2527d242ff10ff0841c22574ce98cac5">More...</a><br /></td></tr>
<tr class="separator:a2527d242ff10ff0841c22574ce98cac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae246f3e07697ad3d1b9094c3436d82ce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ae246f3e07697ad3d1b9094c3436d82ce">GetVertexLaplacian&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt; getValue, Func&lt; E, double &gt; getWeight, Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt; setLaplace, bool parallel=false)</td></tr>
<tr class="memdesc:ae246f3e07697ad3d1b9094c3436d82ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian of the given vertex attributes using given halfedge weights. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a>  <a href="#ae246f3e07697ad3d1b9094c3436d82ce">More...</a><br /></td></tr>
<tr class="separator:ae246f3e07697ad3d1b9094c3436d82ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721e3700b7b288d9b046978bb588c374"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a721e3700b7b288d9b046978bb588c374">GetVertexLaplacian&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getValue, Func&lt; E, double &gt; getWeight, Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setLaplace, bool parallel=false)</td></tr>
<tr class="memdesc:a721e3700b7b288d9b046978bb588c374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian of the given vertex attributes using given halfedge weights. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a>  <a href="#a721e3700b7b288d9b046978bb588c374">More...</a><br /></td></tr>
<tr class="separator:a721e3700b7b288d9b046978bb588c374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d6c8bbb9492277ab0f7eaef08db3c1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a50d6c8bbb9492277ab0f7eaef08db3c1">NormalizeHalfedgeWeightsAtVertices&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; E, double &gt; getWeight, Action&lt; E, double &gt; setWeight, bool parallel=false)</td></tr>
<tr class="memdesc:a50d6c8bbb9492277ab0f7eaef08db3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes halfedge weights such that the weights of outgoing halfedges around each vertex sum to 1. Note that this breaks weight symmetry between halfedge pairs.  <a href="#a50d6c8bbb9492277ab0f7eaef08db3c1">More...</a><br /></td></tr>
<tr class="separator:a50d6c8bbb9492277ab0f7eaef08db3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f16d15403bd4490c71c51a26181c9d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a50f16d15403bd4490c71c51a26181c9d">GetVertexMorseSmaleLabels&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; V, double &gt; getValue, Action&lt; V, int &gt; setLabel, bool parallel=false)</td></tr>
<tr class="memdesc:a50f16d15403bd4490c71c51a26181c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the morse smale classification for each vertex (0 = normal, 1 = minima, 2 = maxima, 3 = saddle). Assumes halfedges are radially sorted around the given vertices.  <a href="#a50f16d15403bd4490c71c51a26181c9d">More...</a><br /></td></tr>
<tr class="separator:a50f16d15403bd4490c71c51a26181c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecca790caae39500b5bd51751434ea9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#afecca790caae39500b5bd51751434ea9">GetVertexDepths&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources, Func&lt; V, int &gt; getDepth, Action&lt; V, int &gt; setDepth)</td></tr>
<tr class="memdesc:afecca790caae39500b5bd51751434ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum topological depth of each vertex from a collection of sources. Note that corresponding get/set delegates must read/write to the same location.  <a href="#afecca790caae39500b5bd51751434ea9">More...</a><br /></td></tr>
<tr class="separator:afecca790caae39500b5bd51751434ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bc9e927c8ebdf668c9056939280d02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a77bc9e927c8ebdf668c9056939280d02">GetVertexDistances&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, IEnumerable&lt; V &gt; sources, Func&lt; E, double &gt; getLength, Func&lt; V, double &gt; getDistance, Action&lt; V, double &gt; setDistance)</td></tr>
<tr class="memdesc:a77bc9e927c8ebdf668c9056939280d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum topological distance to each vertex from a collection of sources. Note that corresponding get/set delegates must read/write to the same location.  <a href="#a77bc9e927c8ebdf668c9056939280d02">More...</a><br /></td></tr>
<tr class="separator:a77bc9e927c8ebdf668c9056939280d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6150eb5b768f4186931925c8a922c74"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ab6150eb5b768f4186931925c8a922c74">GetVertexIncidenceMatrix&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, double[] result)</td></tr>
<tr class="memdesc:ab6150eb5b768f4186931925c8a922c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entries of the incidence matrix in column-major order.  <a href="#ab6150eb5b768f4186931925c8a922c74">More...</a><br /></td></tr>
<tr class="separator:ab6150eb5b768f4186931925c8a922c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5075f77fb753e475356f4341b83c4ee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ab5075f77fb753e475356f4341b83c4ee">GetVertexAdjacencyMatrix&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, double[] result)</td></tr>
<tr class="memdesc:ab5075f77fb753e475356f4341b83c4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entries of the adjacency matrix in column-major order.  <a href="#ab5075f77fb753e475356f4341b83c4ee">More...</a><br /></td></tr>
<tr class="separator:ab5075f77fb753e475356f4341b83c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7511ef387156ab3ad5586072170915a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ad7511ef387156ab3ad5586072170915a">GetVertexLaplacianMatrix&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, double[] result)</td></tr>
<tr class="memdesc:ad7511ef387156ab3ad5586072170915a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian matrix in column-major order.  <a href="#ad7511ef387156ab3ad5586072170915a">More...</a><br /></td></tr>
<tr class="separator:ad7511ef387156ab3ad5586072170915a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbd406e0f089a493f76904ed3ed44ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a5cbd406e0f089a493f76904ed3ed44ff">GetVertexLaplacianMatrix&lt; V, E &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt; graph, Func&lt; E, double &gt; getWeight, double[] result)</td></tr>
<tr class="memdesc:a5cbd406e0f089a493f76904ed3ed44ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian matrix in column-major order.  <a href="#a5cbd406e0f089a493f76904ed3ed44ff">More...</a><br /></td></tr>
<tr class="separator:a5cbd406e0f089a493f76904ed3ed44ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021a1bff488f15d50c0b5fe32926d5f0"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a021a1bff488f15d50c0b5fe32926d5f0">GetFacesBreadthFirst&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources)</td></tr>
<tr class="memdesc:a021a1bff488f15d50c0b5fe32926d5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns faces in breadth first order via the traversed halfedge.  <a href="#a021a1bff488f15d50c0b5fe32926d5f0">More...</a><br /></td></tr>
<tr class="separator:a021a1bff488f15d50c0b5fe32926d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58109f6877fa05a7cbd20b326f36a1fb"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a58109f6877fa05a7cbd20b326f36a1fb">GetFacesBreadthFirst&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources, IEnumerable&lt; F &gt; exclude)</td></tr>
<tr class="memdesc:a58109f6877fa05a7cbd20b326f36a1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns faces in breadth first order via the traversed halfedge.  <a href="#a58109f6877fa05a7cbd20b326f36a1fb">More...</a><br /></td></tr>
<tr class="separator:a58109f6877fa05a7cbd20b326f36a1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722411a3fb3156c7eb23c0d1688b8b6e"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a722411a3fb3156c7eb23c0d1688b8b6e">GetFacesDepthFirst&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources)</td></tr>
<tr class="memdesc:a722411a3fb3156c7eb23c0d1688b8b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns faces in depth first order via the traversed halfedge.  <a href="#a722411a3fb3156c7eb23c0d1688b8b6e">More...</a><br /></td></tr>
<tr class="separator:a722411a3fb3156c7eb23c0d1688b8b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f467ac895a87609f77a9b154df90d8c"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a6f467ac895a87609f77a9b154df90d8c">GetFacesDepthFirst&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources, IEnumerable&lt; F &gt; exclude)</td></tr>
<tr class="memdesc:a6f467ac895a87609f77a9b154df90d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns faces in depth first order via the traversed halfedge.  <a href="#a6f467ac895a87609f77a9b154df90d8c">More...</a><br /></td></tr>
<tr class="separator:a6f467ac895a87609f77a9b154df90d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8aab4da3e13284e333de1c5a6f9792"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a7a8aab4da3e13284e333de1c5a6f9792">GetFacesPriorityFirst&lt; V, E, F, T &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources, Func&lt; F, T &gt; getPriority)</td></tr>
<tr class="memdesc:a7a8aab4da3e13284e333de1c5a6f9792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns faces in order of increasing priority via the traversed halfedge.  <a href="#a7a8aab4da3e13284e333de1c5a6f9792">More...</a><br /></td></tr>
<tr class="separator:a7a8aab4da3e13284e333de1c5a6f9792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cad5514d14cc769c92ec7851b637577"><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; E &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a8cad5514d14cc769c92ec7851b637577">GetFacesPriorityFirst&lt; V, E, F, T &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources, Func&lt; F, T &gt; getPriority, IEnumerable&lt; F &gt; exclude)</td></tr>
<tr class="memdesc:a8cad5514d14cc769c92ec7851b637577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns faces in order of increasing priority via the traversed halfedge.  <a href="#a8cad5514d14cc769c92ec7851b637577">More...</a><br /></td></tr>
<tr class="separator:a8cad5514d14cc769c92ec7851b637577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a9703e49d92df78f23724d47b93d9d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aa7a9703e49d92df78f23724d47b93d9d">GetHalfedgeAreas&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getCenter, Action&lt; E, double &gt; setAreas, bool parallel=false)</td></tr>
<tr class="memdesc:aa7a9703e49d92df78f23724d47b93d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area associated with each halfedge. This is calculated as W in <a href="http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf">http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf</a>.  <a href="#aa7a9703e49d92df78f23724d47b93d9d">More...</a><br /></td></tr>
<tr class="separator:aa7a9703e49d92df78f23724d47b93d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e3f2c29eda150b873e704b1718838c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a82e3f2c29eda150b873e704b1718838c">GetHalfedgeNormals&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setNormal, bool parallel=false)</td></tr>
<tr class="separator:a82e3f2c29eda150b873e704b1718838c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d07490f712a6393f898ff10e93f5dd3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a5d07490f712a6393f898ff10e93f5dd3">GetHalfedgeUnitNormals&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setNormal, bool parallel=false)</td></tr>
<tr class="separator:a5d07490f712a6393f898ff10e93f5dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d7a2780b962dd99606d123b63aa6ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a48d7a2780b962dd99606d123b63aa6ca">GetDihedralAngles&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getNormal, Action&lt; E, double &gt; setAngle, bool parallel=false)</td></tr>
<tr class="memdesc:a48d7a2780b962dd99606d123b63aa6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcuated as the exterior between adjacent faces. Result is in range [0 - 2Pi]. Assumes the given face normals are unitized.  <a href="#a48d7a2780b962dd99606d123b63aa6ca">More...</a><br /></td></tr>
<tr class="separator:a48d7a2780b962dd99606d123b63aa6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b983b5cf40298839c6883cdd5fda8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ad5b983b5cf40298839c6883cdd5fda8c">GetHalfedgeCotangents&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; E, double &gt; setCotangent, bool parallel=false)</td></tr>
<tr class="memdesc:ad5b983b5cf40298839c6883cdd5fda8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cotangent of the angle opposite each halfedge. Assumes triangular faces. <a href="http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf">http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf</a>  <a href="#ad5b983b5cf40298839c6883cdd5fda8c">More...</a><br /></td></tr>
<tr class="separator:ad5b983b5cf40298839c6883cdd5fda8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af307a1374397b2d6bfcc6b39be65aa7b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#af307a1374397b2d6bfcc6b39be65aa7b">GetHalfedgeCotanWeights&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; E, double &gt; setWeight, bool parallel=false)</td></tr>
<tr class="memdesc:af307a1374397b2d6bfcc6b39be65aa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area-dependant cotangent weight for each halfedge. Based on Meyer and Desbrun's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Assumes triangular faces.  <a href="#af307a1374397b2d6bfcc6b39be65aa7b">More...</a><br /></td></tr>
<tr class="separator:af307a1374397b2d6bfcc6b39be65aa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee108c84798f77a04e594d4449f2ca9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a5ee108c84798f77a04e594d4449f2ca9">GetHalfedgeCotanWeights&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; V, double &gt; setArea, Func&lt; E, double &gt; getWeight, Action&lt; E, double &gt; setWeight)</td></tr>
<tr class="memdesc:a5ee108c84798f77a04e594d4449f2ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area-dependant cotangent weight for each halfedge along with the barycentric dual area of each vertex. Based on Meyer and Desbrun's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces.  <a href="#a5ee108c84798f77a04e594d4449f2ca9">More...</a><br /></td></tr>
<tr class="separator:a5ee108c84798f77a04e594d4449f2ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae137e7094f5b751537a333045c3344a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ae137e7094f5b751537a333045c3344a5">GetEdgeDepths&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; E &gt; sources, Func&lt; E, int &gt; getDepth, Action&lt; E, int &gt; setDepth)</td></tr>
<tr class="memdesc:ae137e7094f5b751537a333045c3344a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum topological depth of each edge from a collection of sources. Note that corresponding get/set delegates must read/write to the same location.  <a href="#ae137e7094f5b751537a333045c3344a5">More...</a><br /></td></tr>
<tr class="separator:ae137e7094f5b751537a333045c3344a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8568876b4d6c49e442f7586e5d5660d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a8568876b4d6c49e442f7586e5d5660d0">GetEdgeCotanWeights&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; E, double &gt; setWeight, bool parallel=false)</td></tr>
<tr class="memdesc:a8568876b4d6c49e442f7586e5d5660d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cotangent weight for each edge (symmetric). Based on Pinkall and Polthier's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Assumes triangular faces.  <a href="#a8568876b4d6c49e442f7586e5d5660d0">More...</a><br /></td></tr>
<tr class="separator:a8568876b4d6c49e442f7586e5d5660d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4336c28116283f81785c68ead87f17"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#afe4336c28116283f81785c68ead87f17">GetEdgeCotanWeights&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; E, double &gt; setWeight, bool parallel=false)</td></tr>
<tr class="memdesc:afe4336c28116283f81785c68ead87f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area-dependant cotangent weight for each edge (symmetric). Based on Levy and Vallet's derivation of the symmetric Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Assumes triangular faces.  <a href="#afe4336c28116283f81785c68ead87f17">More...</a><br /></td></tr>
<tr class="separator:afe4336c28116283f81785c68ead87f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07eacd3a011146bef17759dfd8f71e1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ab07eacd3a011146bef17759dfd8f71e1">GetEdgeCotanWeights&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; V, double &gt; setArea, Func&lt; E, double &gt; getWeight, Action&lt; E, double &gt; setWeight)</td></tr>
<tr class="memdesc:ab07eacd3a011146bef17759dfd8f71e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area-dependant cotangent weight for each edge (symmetric) along with the barycentric dual area of each vertex. Based on Levy and Vallet's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces.  <a href="#ab07eacd3a011146bef17759dfd8f71e1">More...</a><br /></td></tr>
<tr class="separator:ab07eacd3a011146bef17759dfd8f71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeca3d2510308900ff59c86ae9b93048"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aeeca3d2510308900ff59c86ae9b93048">GetVertexAreas&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getCenter, Action&lt; V, double &gt; setArea, bool parallel=false)</td></tr>
<tr class="separator:aeeca3d2510308900ff59c86ae9b93048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdbfcb31c6a33a4382964f560de9d50"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a1fdbfcb31c6a33a4382964f560de9d50">GetVertexAreas&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; E, double &gt; getArea, Action&lt; V, double &gt; setArea, bool parallel=false)</td></tr>
<tr class="separator:a1fdbfcb31c6a33a4382964f560de9d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07e94cfce754f23d8c6ed7354bfea3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a8f07e94cfce754f23d8c6ed7354bfea3">GetVertexAreasBarycentric&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; V, double &gt; setArea)</td></tr>
<tr class="memdesc:a8f07e94cfce754f23d8c6ed7354bfea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the barycentric dual area around each vertex as per <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 7) Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces.  <a href="#a8f07e94cfce754f23d8c6ed7354bfea3">More...</a><br /></td></tr>
<tr class="separator:a8f07e94cfce754f23d8c6ed7354bfea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea2edef1f6c939d4424aa7ad846f6d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#adea2edef1f6c939d4424aa7ad846f6d2">GetVertexAreasCircumcentric&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; V, double &gt; setArea)</td></tr>
<tr class="memdesc:adea2edef1f6c939d4424aa7ad846f6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the circumcentric dual area around each vertex as per <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 7) Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces.  <a href="#adea2edef1f6c939d4424aa7ad846f6d2">More...</a><br /></td></tr>
<tr class="separator:adea2edef1f6c939d4424aa7ad846f6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815e7e5a31e757c8ee16d8503c5904e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a815e7e5a31e757c8ee16d8503c5904e4">GetVertexAreasMixed&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; V, double &gt; setArea)</td></tr>
<tr class="memdesc:a815e7e5a31e757c8ee16d8503c5904e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mixed dual area around each vertex as per <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 7) Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces.  <a href="#a815e7e5a31e757c8ee16d8503c5904e4">More...</a><br /></td></tr>
<tr class="separator:a815e7e5a31e757c8ee16d8503c5904e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fa0d470280854209407776ecf52504"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a87fa0d470280854209407776ecf52504">GetVertexCirclePackingRadii&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; E, double &gt; getLength, Action&lt; V, double &gt; setRadius, bool parallel=false)</td></tr>
<tr class="memdesc:a87fa0d470280854209407776ecf52504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the circle packing radii for each vertex. Assumes the mesh is a circle packing mesh <a href="http://www.geometrie.tuwien.ac.at/hoebinger/mhoebinger_files/circlepackings.pdf">http://www.geometrie.tuwien.ac.at/hoebinger/mhoebinger_files/circlepackings.pdf</a>  <a href="#a87fa0d470280854209407776ecf52504">More...</a><br /></td></tr>
<tr class="separator:a87fa0d470280854209407776ecf52504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981ac1f2d9a96851f49075ca375cae64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a981ac1f2d9a96851f49075ca375cae64">GetVertexMeanCurvature&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getLaplace, Action&lt; V, double &gt; setCurvature, bool parallel=false)</td></tr>
<tr class="memdesc:a981ac1f2d9a96851f49075ca375cae64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated as the signed magnitude of the vertex laplacian with respect to the vertex normal. <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 47)  <a href="#a981ac1f2d9a96851f49075ca375cae64">More...</a><br /></td></tr>
<tr class="separator:a981ac1f2d9a96851f49075ca375cae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3cbeff57416eb3ef31819a3bff595a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a6c3cbeff57416eb3ef31819a3bff595a">GetVertexMeanCurvatureSigned&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getLaplace, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getNormal, Action&lt; V, double &gt; setCurvature, bool parallel=false)</td></tr>
<tr class="memdesc:a6c3cbeff57416eb3ef31819a3bff595a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated as the signed magnitude of the vertex laplacian with respect to the vertex normal. <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 47)  <a href="#a6c3cbeff57416eb3ef31819a3bff595a">More...</a><br /></td></tr>
<tr class="separator:a6c3cbeff57416eb3ef31819a3bff595a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca909d2ff7c3e0f96cb2fa7503a815f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aca909d2ff7c3e0f96cb2fa7503a815f2">GetVertexGaussianCurvature&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; V, double &gt; getArea, Action&lt; V, double &gt; setCurvature, bool parallel=false)</td></tr>
<tr class="memdesc:aca909d2ff7c3e0f96cb2fa7503a815f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated as the angle defect around each vertex.  <a href="#aca909d2ff7c3e0f96cb2fa7503a815f2">More...</a><br /></td></tr>
<tr class="separator:aca909d2ff7c3e0f96cb2fa7503a815f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82375bcdd4a3ff34b97449587462127b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a82375bcdd4a3ff34b97449587462127b">GetVertexGaussianCurvature&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; E, double &gt; getAngle, Func&lt; V, double &gt; getArea, Action&lt; V, double &gt; setCurvature, bool parallel=false)</td></tr>
<tr class="memdesc:a82375bcdd4a3ff34b97449587462127b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated as the angle defect around each vertex.  <a href="#a82375bcdd4a3ff34b97449587462127b">More...</a><br /></td></tr>
<tr class="separator:a82375bcdd4a3ff34b97449587462127b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1577bb1be0cd1e017a201abd76c0007"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ae1577bb1be0cd1e017a201abd76c0007">GetVertexNormals&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setNormal, bool parallel=false)</td></tr>
<tr class="memdesc:ae1577bb1be0cd1e017a201abd76c0007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates vertex normals as the area-weighted sum of halfedge normals around each vertex. Vertex normals are unitized by default. <a href="http://libigl.github.io/libigl/tutorial/tutorial.html#normals">http://libigl.github.io/libigl/tutorial/tutorial.html#normals</a>  <a href="#ae1577bb1be0cd1e017a201abd76c0007">More...</a><br /></td></tr>
<tr class="separator:ae1577bb1be0cd1e017a201abd76c0007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80db2febb3f000ed53da3e4e1ca26f6b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a80db2febb3f000ed53da3e4e1ca26f6b">GetVertexNormals&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getNormal, Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setNormal, bool parallel=false)</td></tr>
<tr class="memdesc:a80db2febb3f000ed53da3e4e1ca26f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates vertex normals as the sum of halfedge normals around each vertex. Vertex normals are unitized by default. <a href="http://libigl.github.io/libigl/tutorial/tutorial.html#normals">http://libigl.github.io/libigl/tutorial/tutorial.html#normals</a>  <a href="#a80db2febb3f000ed53da3e4e1ca26f6b">More...</a><br /></td></tr>
<tr class="separator:a80db2febb3f000ed53da3e4e1ca26f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa3915c45cdd850116fb999462105e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#abaa3915c45cdd850116fb999462105e7">GetFaceDegrees&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Action&lt; F, int &gt; setDegree, bool parallel=false)</td></tr>
<tr class="separator:abaa3915c45cdd850116fb999462105e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a75f103b7caca4ca640291d4e13bd5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a92a75f103b7caca4ca640291d4e13bd5">NormalizeHalfedgeWeightsInFaces&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; E, double &gt; getWeight, Action&lt; E, double &gt; setWeight, bool parallel=false)</td></tr>
<tr class="memdesc:a92a75f103b7caca4ca640291d4e13bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes halfedge weights such that the weights of halfedges within each face sum to 1. Note that this breaks weight symmetry between halfedge pairs.  <a href="#a92a75f103b7caca4ca640291d4e13bd5">More...</a><br /></td></tr>
<tr class="separator:a92a75f103b7caca4ca640291d4e13bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb0338842383589f1b663bd69d482fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aeeb0338842383589f1b663bd69d482fc">GetFaceBarycenters&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setCenter, bool parallel=false)</td></tr>
<tr class="memdesc:aeeb0338842383589f1b663bd69d482fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the barycenter of each face.  <a href="#aeeb0338842383589f1b663bd69d482fc">More...</a><br /></td></tr>
<tr class="separator:aeeb0338842383589f1b663bd69d482fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafec3c19bab04b4d61400cbef6fb106f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aafec3c19bab04b4d61400cbef6fb106f">GetFaceCircumcenters&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setCenter, bool parallel=false)</td></tr>
<tr class="memdesc:aafec3c19bab04b4d61400cbef6fb106f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the circumcenter of each face. Assumes triangular faces.  <a href="#aafec3c19bab04b4d61400cbef6fb106f">More...</a><br /></td></tr>
<tr class="separator:aafec3c19bab04b4d61400cbef6fb106f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7e68f0d2c04aaabcd19ba6502f67c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a0b7e68f0d2c04aaabcd19ba6502f67c0">GetFaceIncenters&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setCenter, bool parallel=false)</td></tr>
<tr class="memdesc:a0b7e68f0d2c04aaabcd19ba6502f67c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the incenter of each face. Assumes triangular faces.  <a href="#a0b7e68f0d2c04aaabcd19ba6502f67c0">More...</a><br /></td></tr>
<tr class="separator:a0b7e68f0d2c04aaabcd19ba6502f67c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f7a93993d6a177ed8dfeb63a955ccc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#af9f7a93993d6a177ed8dfeb63a955ccc">GetFaceIncenters&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; E, double &gt; getLength, Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setCenter, bool parallel=false)</td></tr>
<tr class="memdesc:af9f7a93993d6a177ed8dfeb63a955ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the incenter of each face. Assumes triangular faces.  <a href="#af9f7a93993d6a177ed8dfeb63a955ccc">More...</a><br /></td></tr>
<tr class="separator:af9f7a93993d6a177ed8dfeb63a955ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad446eaf18f98f89195e0184d369d261f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ad446eaf18f98f89195e0184d369d261f">GetFaceNormals&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setNormal, bool parallel=false)</td></tr>
<tr class="memdesc:ad446eaf18f98f89195e0184d369d261f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates face normals as the area-weighted sum of halfedge normals in each face. Face normals are unitized by default.  <a href="#ad446eaf18f98f89195e0184d369d261f">More...</a><br /></td></tr>
<tr class="separator:ad446eaf18f98f89195e0184d369d261f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04134f06804ed9c324c93202b99164f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#af04134f06804ed9c324c93202b99164f">GetFaceNormals&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getNormal, Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setNormal, bool parallel=false)</td></tr>
<tr class="memdesc:af04134f06804ed9c324c93202b99164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates face normals as the sum of halfedge normals in each face. Face normals are unitized by default.  <a href="#af04134f06804ed9c324c93202b99164f">More...</a><br /></td></tr>
<tr class="separator:af04134f06804ed9c324c93202b99164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5921ae2a0736c4bb5fe29d609d3b472"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#af5921ae2a0736c4bb5fe29d609d3b472">GetFaceNormalsTri&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; setNormal, bool parallel=false)</td></tr>
<tr class="memdesc:af5921ae2a0736c4bb5fe29d609d3b472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates face normals as the normal of the first halfedge in each face. Face normals are unitized by default. Assumes triangular faces.  <a href="#af5921ae2a0736c4bb5fe29d609d3b472">More...</a><br /></td></tr>
<tr class="separator:af5921ae2a0736c4bb5fe29d609d3b472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1665a4bb83ef8b4cb8830f20f1b6d4f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a1665a4bb83ef8b4cb8830f20f1b6d4f3">GetFaceAreas&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getCenter, Action&lt; F, double &gt; setArea, bool parallel=false)</td></tr>
<tr class="separator:a1665a4bb83ef8b4cb8830f20f1b6d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ed17b547f5f585fbe78a7f23f86433"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#aa7ed17b547f5f585fbe78a7f23f86433">GetFaceAreasTri&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; F, double &gt; setArea, bool parallel=false)</td></tr>
<tr class="memdesc:aa7ed17b547f5f585fbe78a7f23f86433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the area of each face. Assumes triangular faces.  <a href="#aa7ed17b547f5f585fbe78a7f23f86433">More...</a><br /></td></tr>
<tr class="separator:aa7ed17b547f5f585fbe78a7f23f86433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ef004c1185443d6f2e1e73d95adb4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ae3ef004c1185443d6f2e1e73d95adb4e">GetFacePlanarity&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt; getPosition, Action&lt; F, double &gt; setPlanarity, bool parallel=false)</td></tr>
<tr class="memdesc:ae3ef004c1185443d6f2e1e73d95adb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the planar deviation for each face.  <a href="#ae3ef004c1185443d6f2e1e73d95adb4e">More...</a><br /></td></tr>
<tr class="separator:ae3ef004c1185443d6f2e1e73d95adb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ebbdd9a9c453e7872a5f4f4baba638"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a53ebbdd9a9c453e7872a5f4f4baba638">GetFaceDepths&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources, Func&lt; F, int &gt; getDepth, Action&lt; F, int &gt; setDepth)</td></tr>
<tr class="memdesc:a53ebbdd9a9c453e7872a5f4f4baba638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum topological depth of all faces connected to a set of sources. Note that corresponding get/set delegates must read/write to the same location.  <a href="#a53ebbdd9a9c453e7872a5f4f4baba638">More...</a><br /></td></tr>
<tr class="separator:a53ebbdd9a9c453e7872a5f4f4baba638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9837ba3203cca022ce80453a2eb043a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a9837ba3203cca022ce80453a2eb043a3">GetFaceDistances&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, IEnumerable&lt; F &gt; sources, Func&lt; E, double &gt; getLength, Func&lt; F, double &gt; getDistance, Action&lt; F, double &gt; setDistance)</td></tr>
<tr class="memdesc:a9837ba3203cca022ce80453a2eb043a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum topological distance to each face from a collection of sources. Note that corresponding get/set delegates must read/write to the same location.  <a href="#a9837ba3203cca022ce80453a2eb043a3">More...</a><br /></td></tr>
<tr class="separator:a9837ba3203cca022ce80453a2eb043a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50face1c6ded41cfa9b4c2b8aa52f686"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a50face1c6ded41cfa9b4c2b8aa52f686">GetFaceIncidenceMatrix&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, double[] result)</td></tr>
<tr class="memdesc:a50face1c6ded41cfa9b4c2b8aa52f686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entries of the incidence matrix in column-major order.  <a href="#a50face1c6ded41cfa9b4c2b8aa52f686">More...</a><br /></td></tr>
<tr class="separator:a50face1c6ded41cfa9b4c2b8aa52f686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd7fde8bc63318406a6dfa20e782bd7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a2dd7fde8bc63318406a6dfa20e782bd7">GetFaceAdjacencyMatrix&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, double[] result)</td></tr>
<tr class="memdesc:a2dd7fde8bc63318406a6dfa20e782bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entries of the adjacency matrix in column-major order.  <a href="#a2dd7fde8bc63318406a6dfa20e782bd7">More...</a><br /></td></tr>
<tr class="separator:a2dd7fde8bc63318406a6dfa20e782bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d659e08d98bfdb55523431e8c361555"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#a1d659e08d98bfdb55523431e8c361555">GetFaceLaplacianMatrix&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, double[] result)</td></tr>
<tr class="memdesc:a1d659e08d98bfdb55523431e8c361555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian matrix in column-major order.  <a href="#a1d659e08d98bfdb55523431e8c361555">More...</a><br /></td></tr>
<tr class="separator:a1d659e08d98bfdb55523431e8c361555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0346d3830adc698461fd3528cdf7621"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_spatial_slur_1_1_slur_mesh_1_1_i_he_structure_extensions.html#ab0346d3830adc698461fd3528cdf7621">GetFaceLaplacianMatrix&lt; V, E, F &gt;</a> (this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt; mesh, Func&lt; E, double &gt; getWeight, double[] result)</td></tr>
<tr class="memdesc:ab0346d3830adc698461fd3528cdf7621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Laplacian matrix in column-major order.  <a href="#ab0346d3830adc698461fd3528cdf7621">More...</a><br /></td></tr>
<tr class="separator:ab0346d3830adc698461fd3528cdf7621"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0c25e5c4452802ad9de205c03547e618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c25e5c4452802ad9de205c03547e618">&#9670;&nbsp;</a></span>CountConnectedComponents< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SpatialSlur.SlurMesh.IHeStructureExtensions.CountConnectedComponents&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of connected components in the graph. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac3d8d9b054a218122a14323bb6ab6f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d8d9b054a218122a14323bb6ab6f06">&#9670;&nbsp;</a></span>GetConnectedComponents< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetConnectedComponents&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first halfedge from each connected component in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a48d7a2780b962dd99606d123b63aa6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d7a2780b962dd99606d123b63aa6ca">&#9670;&nbsp;</a></span>GetDihedralAngles< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetDihedralAngles&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calcuated as the exterior between adjacent faces. Result is in range [0 - 2Pi]. Assumes the given face normals are unitized. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a135c02a70215035b83572ba53d6a4595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135c02a70215035b83572ba53d6a4595">&#9670;&nbsp;</a></span>GetEdgeComponentIndices< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeComponentIndices&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, int &gt;&#160;</td>
          <td class="paramname"><em>setIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connected component index of each edge in the mesh. Also returns the number of connected components. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8568876b4d6c49e442f7586e5d5660d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8568876b4d6c49e442f7586e5d5660d0">&#9670;&nbsp;</a></span>GetEdgeCotanWeights< V, E, F >() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeCotanWeights&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cotangent weight for each edge (symmetric). Based on Pinkall and Polthier's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="afe4336c28116283f81785c68ead87f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4336c28116283f81785c68ead87f17">&#9670;&nbsp;</a></span>GetEdgeCotanWeights< V, E, F >() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeCotanWeights&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area-dependant cotangent weight for each edge (symmetric). Based on Levy and Vallet's derivation of the symmetric Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab07eacd3a011146bef17759dfd8f71e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07eacd3a011146bef17759dfd8f71e1">&#9670;&nbsp;</a></span>GetEdgeCotanWeights< V, E, F >() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeCotanWeights&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area-dependant cotangent weight for each edge (symmetric) along with the barycentric dual area of each vertex. Based on Levy and Vallet's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a2a47415effa524c9f7bbaca65b043081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a47415effa524c9f7bbaca65b043081">&#9670;&nbsp;</a></span>GetEdgeDeltas< V, E >() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeDeltas&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a49445752442bbfee5681c698585e845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49445752442bbfee5681c698585e845a">&#9670;&nbsp;</a></span>GetEdgeDeltas< V, E >() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeDeltas&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt;&#160;</td>
          <td class="paramname"><em>setDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab3fd0b0658f93d579c52094808c42050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fd0b0658f93d579c52094808c42050">&#9670;&nbsp;</a></span>GetEdgeDeltas< V, E >() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeDeltas&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a4e691f5dec2349b6bfae6f8e25dabfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e691f5dec2349b6bfae6f8e25dabfc8">&#9670;&nbsp;</a></span>GetEdgeDepths< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeDepths&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, int &gt;&#160;</td>
          <td class="paramname"><em>getDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, int &gt;&#160;</td>
          <td class="paramname"><em>setDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum topological depth of each edge from a collection of sources. Note that corresponding get/set delegates must read/write to the same location. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae137e7094f5b751537a333045c3344a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae137e7094f5b751537a333045c3344a5">&#9670;&nbsp;</a></span>GetEdgeDepths< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeDepths&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, int &gt;&#160;</td>
          <td class="paramname"><em>getDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, int &gt;&#160;</td>
          <td class="paramname"><em>setDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum topological depth of each edge from a collection of sources. Note that corresponding get/set delegates must read/write to the same location. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a0006bc10f877c8e6d40749a140040774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0006bc10f877c8e6d40749a140040774">&#9670;&nbsp;</a></span>GetEdgeLengths< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeLengths&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a3c64678eb7fc396772bbd6a8e47e86b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c64678eb7fc396772bbd6a8e47e86b7">&#9670;&nbsp;</a></span>GetEdgeLengthSum< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeLengthSum&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">getPosition</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac6ecfb70d9b98547787fd0cb1a11a8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ecfb70d9b98547787fd0cb1a11a8aa">&#9670;&nbsp;</a></span>GetEdgesBreadthFirst< V, E >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgesBreadthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns edges in breadth first order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a927a399748e1bbeb57a5bcf4bba300ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927a399748e1bbeb57a5bcf4bba300ec">&#9670;&nbsp;</a></span>GetEdgesBreadthFirst< V, E >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgesBreadthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns edges in breadth first order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a9a8a8810107dc9c8f193f99310aa769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a8810107dc9c8f193f99310aa769e">&#9670;&nbsp;</a></span>GetEdgesDepthFirst< V, E >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgesDepthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns edges in depth first order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa22697df40e9068792d6e0f0575b35f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22697df40e9068792d6e0f0575b35f1">&#9670;&nbsp;</a></span>GetEdgesDepthFirst< V, E >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgesDepthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns edges in depth first order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8830116787d213e17451a9790e7ab1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8830116787d213e17451a9790e7ab1d3">&#9670;&nbsp;</a></span>GetEdgesPriorityFirst< V, E, T >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgesPriorityFirst&lt; V, E, T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, T &gt;&#160;</td>
          <td class="paramname"><em>getPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns edges in order of increasing priority. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">getPriority</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IComparable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="afe91bbbf3dd6561305282efcf7fa635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe91bbbf3dd6561305282efcf7fa635c">&#9670;&nbsp;</a></span>GetEdgesPriorityFirst< V, E, T >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgesPriorityFirst&lt; V, E, T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, T &gt;&#160;</td>
          <td class="paramname"><em>getPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; E &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns edges in order of increasing priority. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">getPriority</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IComparable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ac6130ffd2dcff67449b8a03d323bdb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6130ffd2dcff67449b8a03d323bdb42">&#9670;&nbsp;</a></span>GetEdgeTangents< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetEdgeTangents&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setTangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a2dd7fde8bc63318406a6dfa20e782bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd7fde8bc63318406a6dfa20e782bd7">&#9670;&nbsp;</a></span>GetFaceAdjacencyMatrix< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceAdjacencyMatrix&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entries of the adjacency matrix in column-major order. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1665a4bb83ef8b4cb8830f20f1b6d4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1665a4bb83ef8b4cb8830f20f1b6d4f3">&#9670;&nbsp;</a></span>GetFaceAreas< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceAreas&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa7ed17b547f5f585fbe78a7f23f86433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ed17b547f5f585fbe78a7f23f86433">&#9670;&nbsp;</a></span>GetFaceAreasTri< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceAreasTri&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area of each face. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aeeb0338842383589f1b663bd69d482fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb0338842383589f1b663bd69d482fc">&#9670;&nbsp;</a></span>GetFaceBarycenters< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceBarycenters&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the barycenter of each face. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aafec3c19bab04b4d61400cbef6fb106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafec3c19bab04b4d61400cbef6fb106f">&#9670;&nbsp;</a></span>GetFaceCircumcenters< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceCircumcenters&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the circumcenter of each face. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abaa3915c45cdd850116fb999462105e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa3915c45cdd850116fb999462105e7">&#9670;&nbsp;</a></span>GetFaceDegrees< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceDegrees&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, int &gt;&#160;</td>
          <td class="paramname"><em>setDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a53ebbdd9a9c453e7872a5f4f4baba638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ebbdd9a9c453e7872a5f4f4baba638">&#9670;&nbsp;</a></span>GetFaceDepths< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceDepths&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, int &gt;&#160;</td>
          <td class="paramname"><em>getDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, int &gt;&#160;</td>
          <td class="paramname"><em>setDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum topological depth of all faces connected to a set of sources. Note that corresponding get/set delegates must read/write to the same location. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a9837ba3203cca022ce80453a2eb043a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9837ba3203cca022ce80453a2eb043a3">&#9670;&nbsp;</a></span>GetFaceDistances< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceDistances&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, double &gt;&#160;</td>
          <td class="paramname"><em>getDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, double &gt;&#160;</td>
          <td class="paramname"><em>setDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum topological distance to each face from a collection of sources. Note that corresponding get/set delegates must read/write to the same location. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a0b7e68f0d2c04aaabcd19ba6502f67c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7e68f0d2c04aaabcd19ba6502f67c0">&#9670;&nbsp;</a></span>GetFaceIncenters< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceIncenters&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the incenter of each face. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af9f7a93993d6a177ed8dfeb63a955ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f7a93993d6a177ed8dfeb63a955ccc">&#9670;&nbsp;</a></span>GetFaceIncenters< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceIncenters&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the incenter of each face. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a50face1c6ded41cfa9b4c2b8aa52f686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50face1c6ded41cfa9b4c2b8aa52f686">&#9670;&nbsp;</a></span>GetFaceIncidenceMatrix< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceIncidenceMatrix&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entries of the incidence matrix in column-major order. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1d659e08d98bfdb55523431e8c361555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d659e08d98bfdb55523431e8c361555">&#9670;&nbsp;</a></span>GetFaceLaplacianMatrix< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceLaplacianMatrix&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian matrix in column-major order. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab0346d3830adc698461fd3528cdf7621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0346d3830adc698461fd3528cdf7621">&#9670;&nbsp;</a></span>GetFaceLaplacianMatrix< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceLaplacianMatrix&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian matrix in column-major order. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad446eaf18f98f89195e0184d369d261f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad446eaf18f98f89195e0184d369d261f">&#9670;&nbsp;</a></span>GetFaceNormals< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceNormals&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates face normals as the area-weighted sum of halfedge normals in each face. Face normals are unitized by default. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af04134f06804ed9c324c93202b99164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04134f06804ed9c324c93202b99164f">&#9670;&nbsp;</a></span>GetFaceNormals< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceNormals&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates face normals as the sum of halfedge normals in each face. Face normals are unitized by default. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af5921ae2a0736c4bb5fe29d609d3b472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5921ae2a0736c4bb5fe29d609d3b472">&#9670;&nbsp;</a></span>GetFaceNormalsTri< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFaceNormalsTri&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates face normals as the normal of the first halfedge in each face. Face normals are unitized by default. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae3ef004c1185443d6f2e1e73d95adb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ef004c1185443d6f2e1e73d95adb4e">&#9670;&nbsp;</a></span>GetFacePlanarity< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetFacePlanarity&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; F, double &gt;&#160;</td>
          <td class="paramname"><em>setPlanarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the planar deviation for each face. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a021a1bff488f15d50c0b5fe32926d5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021a1bff488f15d50c0b5fe32926d5f0">&#9670;&nbsp;</a></span>GetFacesBreadthFirst< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetFacesBreadthFirst&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns faces in breadth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a58109f6877fa05a7cbd20b326f36a1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58109f6877fa05a7cbd20b326f36a1fb">&#9670;&nbsp;</a></span>GetFacesBreadthFirst< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetFacesBreadthFirst&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns faces in breadth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a722411a3fb3156c7eb23c0d1688b8b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722411a3fb3156c7eb23c0d1688b8b6e">&#9670;&nbsp;</a></span>GetFacesDepthFirst< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetFacesDepthFirst&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns faces in depth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a6f467ac895a87609f77a9b154df90d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f467ac895a87609f77a9b154df90d8c">&#9670;&nbsp;</a></span>GetFacesDepthFirst< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetFacesDepthFirst&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns faces in depth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a7a8aab4da3e13284e333de1c5a6f9792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8aab4da3e13284e333de1c5a6f9792">&#9670;&nbsp;</a></span>GetFacesPriorityFirst< V, E, F, T >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetFacesPriorityFirst&lt; V, E, F, T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, T &gt;&#160;</td>
          <td class="paramname"><em>getPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns faces in order of increasing priority via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">getPriority</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IComparable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8cad5514d14cc769c92ec7851b637577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cad5514d14cc769c92ec7851b637577">&#9670;&nbsp;</a></span>GetFacesPriorityFirst< V, E, F, T >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetFacesPriorityFirst&lt; V, E, F, T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, T &gt;&#160;</td>
          <td class="paramname"><em>getPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; F &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns faces in order of increasing priority via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">getPriority</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IComparable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1d328dfdf8f0d012cddb1d74e8c05a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d328dfdf8f0d012cddb1d74e8c05a00">&#9670;&nbsp;</a></span>GetHalfedgeAngles< V, E >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeAngles&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a09fc50cc7c07a6321ce6edf57d714b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fc50cc7c07a6321ce6edf57d714b15">&#9670;&nbsp;</a></span>GetHalfedgeAngles< V, E >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeAngles&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa7a9703e49d92df78f23724d47b93d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a9703e49d92df78f23724d47b93d9d">&#9670;&nbsp;</a></span>GetHalfedgeAreas< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeAreas&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setAreas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area associated with each halfedge. This is calculated as W in <a href="http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf">http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf</a>. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad5b983b5cf40298839c6883cdd5fda8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b983b5cf40298839c6883cdd5fda8c">&#9670;&nbsp;</a></span>GetHalfedgeCotangents< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeCotangents&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setCotangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cotangent of the angle opposite each halfedge. Assumes triangular faces. <a href="http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf">http://www.cs.columbia.edu/~keenan/Projects/Other/TriangleAreasCheatSheet.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af307a1374397b2d6bfcc6b39be65aa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af307a1374397b2d6bfcc6b39be65aa7b">&#9670;&nbsp;</a></span>GetHalfedgeCotanWeights< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeCotanWeights&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area-dependant cotangent weight for each halfedge. Based on Meyer and Desbrun's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5ee108c84798f77a04e594d4449f2ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee108c84798f77a04e594d4449f2ca9">&#9670;&nbsp;</a></span>GetHalfedgeCotanWeights< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeCotanWeights&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the area-dependant cotangent weight for each halfedge along with the barycentric dual area of each vertex. Based on Meyer and Desbrun's derivation of the Laplace-Beltrami operator discussed in <a href="http://reuter.mit.edu/papers/reuter-smi09.pdf">http://reuter.mit.edu/papers/reuter-smi09.pdf</a>. Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a82e3f2c29eda150b873e704b1718838c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e3f2c29eda150b873e704b1718838c">&#9670;&nbsp;</a></span>GetHalfedgeNormals< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeNormals&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5d07490f712a6393f898ff10e93f5dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d07490f712a6393f898ff10e93f5dd3">&#9670;&nbsp;</a></span>GetHalfedgeUnitNormals< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetHalfedgeUnitNormals&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab5075f77fb753e475356f4341b83c4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5075f77fb753e475356f4341b83c4ee">&#9670;&nbsp;</a></span>GetVertexAdjacencyMatrix< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexAdjacencyMatrix&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entries of the adjacency matrix in column-major order. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aeeca3d2510308900ff59c86ae9b93048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeca3d2510308900ff59c86ae9b93048">&#9670;&nbsp;</a></span>GetVertexAreas< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexAreas&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; F, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1fdbfcb31c6a33a4382964f560de9d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdbfcb31c6a33a4382964f560de9d50">&#9670;&nbsp;</a></span>GetVertexAreas< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexAreas&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8f07e94cfce754f23d8c6ed7354bfea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f07e94cfce754f23d8c6ed7354bfea3">&#9670;&nbsp;</a></span>GetVertexAreasBarycentric< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexAreasBarycentric&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the barycentric dual area around each vertex as per <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 7) Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="adea2edef1f6c939d4424aa7ad846f6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea2edef1f6c939d4424aa7ad846f6d2">&#9670;&nbsp;</a></span>GetVertexAreasCircumcentric< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexAreasCircumcentric&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the circumcentric dual area around each vertex as per <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 7) Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a815e7e5a31e757c8ee16d8503c5904e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815e7e5a31e757c8ee16d8503c5904e4">&#9670;&nbsp;</a></span>GetVertexAreasMixed< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexAreasMixed&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setArea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the mixed dual area around each vertex as per <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 7) Note that corresponding get/set delegates should read/write to the same location. Assumes triangular faces. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a87fa0d470280854209407776ecf52504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fa0d470280854209407776ecf52504">&#9670;&nbsp;</a></span>GetVertexCirclePackingRadii< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexCirclePackingRadii&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the circle packing radii for each vertex. Assumes the mesh is a circle packing mesh <a href="http://www.geometrie.tuwien.ac.at/hoebinger/mhoebinger_files/circlepackings.pdf">http://www.geometrie.tuwien.ac.at/hoebinger/mhoebinger_files/circlepackings.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a6b4cdc2e32bc894bfa0d3c9f0106705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4cdc2e32bc894bfa0d3c9f0106705d">&#9670;&nbsp;</a></span>GetVertexDegrees< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexDegrees&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, int &gt;&#160;</td>
          <td class="paramname"><em>setDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="afecca790caae39500b5bd51751434ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecca790caae39500b5bd51751434ea9">&#9670;&nbsp;</a></span>GetVertexDepths< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexDepths&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, int &gt;&#160;</td>
          <td class="paramname"><em>getDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, int &gt;&#160;</td>
          <td class="paramname"><em>setDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum topological depth of each vertex from a collection of sources. Note that corresponding get/set delegates must read/write to the same location. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a77bc9e927c8ebdf668c9056939280d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bc9e927c8ebdf668c9056939280d02">&#9670;&nbsp;</a></span>GetVertexDistances< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexDistances&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum topological distance to each vertex from a collection of sources. Note that corresponding get/set delegates must read/write to the same location. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aca909d2ff7c3e0f96cb2fa7503a815f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca909d2ff7c3e0f96cb2fa7503a815f2">&#9670;&nbsp;</a></span>GetVertexGaussianCurvature< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexGaussianCurvature&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setCurvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated as the angle defect around each vertex. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a82375bcdd4a3ff34b97449587462127b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82375bcdd4a3ff34b97449587462127b">&#9670;&nbsp;</a></span>GetVertexGaussianCurvature< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexGaussianCurvature&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setCurvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated as the angle defect around each vertex. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab6150eb5b768f4186931925c8a922c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6150eb5b768f4186931925c8a922c74">&#9670;&nbsp;</a></span>GetVertexIncidenceMatrix< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexIncidenceMatrix&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entries of the incidence matrix in column-major order. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8a18e5e6ff85b84279d134c9942c4199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18e5e6ff85b84279d134c9942c4199">&#9670;&nbsp;</a></span>GetVertexLaplacian< V, E >() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacian&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian of the given vertex attributes using a normalized umbrella weighting scheme. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a01f4244f1f995281265dc8394b2c3d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f4244f1f995281265dc8394b2c3d63">&#9670;&nbsp;</a></span>GetVertexLaplacian< V, E >() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacian&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt;&#160;</td>
          <td class="paramname"><em>setLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian of the given vertex attributes using a normalized umbrella weighting scheme. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a063abbaf126bdabb5604b91e9e6b9675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063abbaf126bdabb5604b91e9e6b9675">&#9670;&nbsp;</a></span>GetVertexLaplacian< V, E >() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacian&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian of the given vertex attributes using a normalized umbrella weighting scheme. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a2527d242ff10ff0841c22574ce98cac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2527d242ff10ff0841c22574ce98cac5">&#9670;&nbsp;</a></span>GetVertexLaplacian< V, E >() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacian&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian of the given vertex attributes using given halfedge weights. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae246f3e07697ad3d1b9094c3436d82ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae246f3e07697ad3d1b9094c3436d82ce">&#9670;&nbsp;</a></span>GetVertexLaplacian< V, E >() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacian&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec2d.html">Vec2d</a> &gt;&#160;</td>
          <td class="paramname"><em>setLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian of the given vertex attributes using given halfedge weights. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a721e3700b7b288d9b046978bb588c374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721e3700b7b288d9b046978bb588c374">&#9670;&nbsp;</a></span>GetVertexLaplacian< V, E >() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacian&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian of the given vertex attributes using given halfedge weights. <a href="https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf">https://www.informatik.hu-berlin.de/forschung/gebiete/viscom/thesis/final/Diplomarbeit_Herholz_201301.pdf</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad7511ef387156ab3ad5586072170915a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7511ef387156ab3ad5586072170915a">&#9670;&nbsp;</a></span>GetVertexLaplacianMatrix< V, E >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacianMatrix&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian matrix in column-major order. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5cbd406e0f089a493f76904ed3ed44ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbd406e0f089a493f76904ed3ed44ff">&#9670;&nbsp;</a></span>GetVertexLaplacianMatrix< V, E >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexLaplacianMatrix&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double []&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Laplacian matrix in column-major order. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a981ac1f2d9a96851f49075ca375cae64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981ac1f2d9a96851f49075ca375cae64">&#9670;&nbsp;</a></span>GetVertexMeanCurvature< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexMeanCurvature&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setCurvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated as the signed magnitude of the vertex laplacian with respect to the vertex normal. <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 47) </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a6c3cbeff57416eb3ef31819a3bff595a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3cbeff57416eb3ef31819a3bff595a">&#9670;&nbsp;</a></span>GetVertexMeanCurvatureSigned< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexMeanCurvatureSigned&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getLaplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>setCurvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated as the signed magnitude of the vertex laplacian with respect to the vertex normal. <a href="http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf">http://www.hao-li.com/cs599-ss2015/slides/Lecture04.1.pdf</a> (p 47) </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a50f16d15403bd4490c71c51a26181c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f16d15403bd4490c71c51a26181c9d">&#9670;&nbsp;</a></span>GetVertexMorseSmaleLabels< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexMorseSmaleLabels&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, double &gt;&#160;</td>
          <td class="paramname"><em>getValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, int &gt;&#160;</td>
          <td class="paramname"><em>setLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the morse smale classification for each vertex (0 = normal, 1 = minima, 2 = maxima, 3 = saddle). Assumes halfedges are radially sorted around the given vertices. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae1577bb1be0cd1e017a201abd76c0007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1577bb1be0cd1e017a201abd76c0007">&#9670;&nbsp;</a></span>GetVertexNormals< V, E, F >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexNormals&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates vertex normals as the area-weighted sum of halfedge normals around each vertex. Vertex normals are unitized by default. <a href="http://libigl.github.io/libigl/tutorial/tutorial.html#normals">http://libigl.github.io/libigl/tutorial/tutorial.html#normals</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a80db2febb3f000ed53da3e4e1ca26f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80db2febb3f000ed53da3e4e1ca26f6b">&#9670;&nbsp;</a></span>GetVertexNormals< V, E, F >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.GetVertexNormals&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>getNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; V, <a class="el" href="struct_spatial_slur_1_1_slur_core_1_1_vec3d.html">Vec3d</a> &gt;&#160;</td>
          <td class="paramname"><em>setNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates vertex normals as the sum of halfedge normals around each vertex. Vertex normals are unitized by default. <a href="http://libigl.github.io/libigl/tutorial/tutorial.html#normals">http://libigl.github.io/libigl/tutorial/tutorial.html#normals</a> </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa08e2f1e6653508428ea2590bcd2a143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08e2f1e6653508428ea2590bcd2a143">&#9670;&nbsp;</a></span>GetVerticesBreadthFirst< V, E >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetVerticesBreadthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vertices in breadth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5b2692310d9f476d0c8ad3701fddbc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2692310d9f476d0c8ad3701fddbc2f">&#9670;&nbsp;</a></span>GetVerticesBreadthFirst< V, E >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetVerticesBreadthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vertices in breadth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a9767b01aec019fb9df5efadd2e983ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9767b01aec019fb9df5efadd2e983ab0">&#9670;&nbsp;</a></span>GetVerticesDepthFirst< V, E >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetVerticesDepthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vertices in depth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af2c9c4b62fc592840d45e0e16ca51662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c9c4b62fc592840d45e0e16ca51662">&#9670;&nbsp;</a></span>GetVerticesDepthFirst< V, E >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetVerticesDepthFirst&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vertices in depth first order via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab095a0437b7977ffe1e571264ee9350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab095a0437b7977ffe1e571264ee9350e">&#9670;&nbsp;</a></span>GetVerticesPriorityFirst< V, E, T >() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetVerticesPriorityFirst&lt; V, E, T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, T &gt;&#160;</td>
          <td class="paramname"><em>getPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vertices in order of increasing priority via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">getPriority</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IComparable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a19ac13c72844bfc1de0df775f8e92760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ac13c72844bfc1de0df775f8e92760">&#9670;&nbsp;</a></span>GetVerticesPriorityFirst< V, E, T >() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;E&gt; SpatialSlur.SlurMesh.IHeStructureExtensions.GetVerticesPriorityFirst&lt; V, E, T &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; V, T &gt;&#160;</td>
          <td class="paramname"><em>getPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IEnumerable&lt; V &gt;&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vertices in order of increasing priority via the traversed halfedge. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
    <tr><td class="paramname">E</td><td></td></tr>
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td></td></tr>
    <tr><td class="paramname">sources</td><td></td></tr>
    <tr><td class="paramname">getPriority</td><td></td></tr>
    <tr><td class="paramname">exclude</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>IComparable&lt;T&gt;</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a50d6c8bbb9492277ab0f7eaef08db3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d6c8bbb9492277ab0f7eaef08db3c1">&#9670;&nbsp;</a></span>NormalizeHalfedgeWeightsAtVertices< V, E >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.NormalizeHalfedgeWeightsAtVertices&lt; V, E &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes halfedge weights such that the weights of outgoing halfedges around each vertex sum to 1. Note that this breaks weight symmetry between halfedge pairs. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a92a75f103b7caca4ca640291d4e13bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a75f103b7caca4ca640291d4e13bd5">&#9670;&nbsp;</a></span>NormalizeHalfedgeWeightsInFaces< V, E, F >()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SpatialSlur.SlurMesh.IHeStructureExtensions.NormalizeHalfedgeWeightsInFaces&lt; V, E, F &gt; </td>
          <td>(</td>
          <td class="paramtype">this <a class="el" href="interface_spatial_slur_1_1_slur_mesh_1_1_i_he_structure.html">IHeStructure</a>&lt; V, E, F &gt;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>getWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&lt; E, double &gt;&#160;</td>
          <td class="paramname"><em>setWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes halfedge weights such that the weights of halfedges within each face sum to 1. Note that this breaks weight symmetry between halfedge pairs. </p>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>IHeVertex</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>V</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>IHalfedge</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>E</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>HeElement</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>IHeFace</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>V</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>E</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>F</em></td><td>&#160;:</td><td valign="top"><em>F</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/David/Google Drive/Visual Studio/Repos/SpatialSlur/SpatialSlur/SlurMesh/Interfaces/<a class="el" href="_i_he_structure_8cs.html">IHeStructure.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
